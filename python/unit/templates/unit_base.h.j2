#pragma once
#include <memory>
#include <vector>

#include <basis/unit.h>
#include <basis/unit/args.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
{% for include in cpp_includes %}
#include <{{include}}>
{% endfor %}
#pragma clang diagnostic pop

{% for handler_name in handlers %}
#include <unit/{{unit_name}}/handlers/{{handler_name}}.h>
{% endfor %}

namespace unit::{{unit_name}} {
    using namespace std;
    struct Args : public basis::unit::UnitArguments<Args> {    
        {% for argument_name, argument in args.items() %}
            {% if argument.get('optional', False) %}
                std::optional<{{argument.type}}> {{argument_name}};
            {% else %}
                {{argument.type}} {{argument_name}};
            {% endif %}
        {% endfor %}

        static std::array<std::unique_ptr<basis::unit::ArgumentMetadataBase>, {{args|length}}> argument_metadatas;

        void HandleParsedArgs(argparse::ArgumentParser parser) {
        {% for argument_name, argument in args.items() %}
            {% if argument.get('optional', False) %}
                parser.present("--{{argument_name}}", {{argument_name}});
            {% else %}
                {{argument_name}} = parser.get<{{argument.type}}>("--{{argument_name}}");
            {% endif %}
        {% endfor %}
        }
    };
}

namespace unit::{{unit_name}} {

    // TODO: this won't work with multi threaded units, obviously
    class Base : public basis::SingleThreadedUnit {

        void SetupSerializationHelpers();

        void CreatePublishersSubscribers(const basis::UnitInitializeOptions& options) {
            {% for handler_name in handlers %}
            {{handler_name}}_pubsub.SetupPubSub(options, transport_manager.get(), overall_queue, &thread_pool);
            handlers["{{handler_name}}"] = &{{handler_name}}_pubsub;
            {% endfor %}
        }

    public:
        Base(std::optional<std::string> name_override = {}) 
        : basis::SingleThreadedUnit(name_override.value_or("{{unit_name}}")) {

        }

{% for handler_name in handlers %}
        virtual {{handler_name}}::Output {{handler_name}}(const {{handler_name}}::Input& input) = 0;
{% endfor %}

        virtual void Initialize(const basis::UnitInitializeOptions& options) final override {
            CreatePublishersSubscribers(options);
            SetupSerializationHelpers();
        }
    
    private:
        {% for handler_name in handlers %}
        {{handler_name}}::PubSub {{handler_name}}_pubsub = {
            AUTO_LOGGER.get(),
            [this](auto input){
                return {{handler_name}}(input); 
            }
        };
        {% endfor %}
    };
    
}