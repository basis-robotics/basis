#pragma once

#include <basis/core/transport/subscriber.h>
#include <basis/core/transport/publisher.h>
#include <basis/synchronizers/all.h>
#include <basis/synchronizers/field.h>

{% for serializer in serializers %}
#include <basis/plugins/serialization/{{serializer}}.h>
{% endfor %}

namespace unit::{{unit_name}}::{{handler_name}} {
    struct Input {
        basis::core::MonotonicTime time;
{% for input_name, input in inputs.items() %}
        // {{input_name}}
        {{input.cpp_type}} {{input.cpp_topic_name}};
{% endfor %}
        // TODO: this will need metadata around topics to handle deterministic mode
    };

    struct Output {
{% for output_name, output in outputs.items() %}
        // {{output_name}}
        {{output.cpp_type}} {{output.cpp_topic_name}};
{% endfor %}
        // TODO: diagnostics, error state, etc
        // TODO: should we take as unique_ptr instead?
    };

{%if sync.type == 'all' %}
    // Simple, synchronize all messages on presence
    using Synchronizer = basis::synchronizers::All<
{%- set comma = joiner(", ") %}
{%- for input_name, input in inputs.items() %}
            {{- comma() }}
            {{input.cpp_type}}
{%- endfor %}
    >;

{% elif sync.type == 'equal' or 'approximate' in sync.type %}
    // Simple, synchronize all messages on presence
    {% if sync.type == 'equal' %}
    using Synchronizer = basis::synchronizers::FieldSyncEqual<
    {% else %}
    using Synchronizer = basis::synchronizers::FieldSyncApproximatelyEqual<
        {{sync.type.approximate}},
    {% endif %}
{%- set comma = joiner(", ") %}
{%- for input_name, input in inputs.items() %}
            {{- comma() }}
            basis::synchronizers::Field<{{input.cpp_type}},
            {%if 'sync_field' in input %}
                {%if input.sync_field.startswith('::') %}
                    &{{input.cpp_message_type}}{{input.sync_field}}
                {% else %}
                    [](const {{input.cpp_message_type}}* msg) {
                        return msg->{{input.sync_field}};
                    }
                {% endif %}
            {% else %}
                nullptr
            {%endif%}
            >
{%- endfor %}
    >;
{% endif %}

    struct PubSub : basis::HandlerPubSub {
        using Callback = std::function<Output(const Input&)>;
        PubSub(std::function<Output(const Input&)> callback, std::function<void(Output&)> publish_callback = nullptr)
        {
            if(!publish_callback) {
                publish_callback = 
                    [this](Output& output){
                        OnOutput(output);
                    };
            }
            synchronizer = std::make_unique<Synchronizer>(
        [this, callback, publish_callback](const basis::core::MonotonicTime& now, auto ...msgs) {
                Output output = callback({now, msgs...});
{% for output_name, output in outputs.items() %}
                assert(output.{{output.cpp_topic_name}} != nullptr);
{% endfor %}

                publish_callback(output);
            }, std::tuple{ 
{%- set comma = joiner(", ") %}
{%- for input_name, input in inputs.items() %}
            {{- comma() }}
            basis::synchronizers::MessageMetadata<{{input.cpp_type}}>{
                .is_optional = {{input.get('optional', False)|lower}},
                .is_cached = {{input.get('cached', False)|lower}},
            }
{%- endfor %}
            }
            );
        }

        ~PubSub() {
            // Remove subscribers first
            {% for input_name, input in inputs.items() %}
            {{input.cpp_topic_name}}_subscriber = nullptr;
            {% endfor %}
            {% if 'rate' in sync %}
            // Ensure that we stop the rate subscriber thread before we destruct the synchronizer
            rate_subsciber = nullptr;
            {% endif %}
            synchronizer = nullptr;
        }

        void SetupPubSub(
            const basis::UnitInitializeOptions& options,
            basis::core::transport::TransportManager* transport_manager,
            std::shared_ptr<basis::core::transport::OutputQueue> output_queue,
            basis::core::threading::ThreadPool* thread_pool);

        void OnOutput(const Output& output) {
{% for output_name, output in outputs.items() %}
        {{output.cpp_topic_name}}_publisher->Publish(output.{{output.cpp_topic_name}});
{%- endfor %}
        }



{% if 'rate' in sync %}
private:
    virtual void OnRateSubscriber(const basis::core::MonotonicTime& now) override {
        // TODO: consume the monotonic time
        synchronizer->ConsumeIfReady(now);
    }

    std::unique_ptr<basis::core::transport::RateSubscriber> rate_subsciber;

public:
{% endif %}
{% for input_name, input in inputs.items() %}
        // {{input_name}}
        std::shared_ptr<basis::core::transport::Subscriber<{{input.cpp_message_type}}>> {{input.cpp_topic_name}}_subscriber;
{% endfor %}
{% for output_name, output in outputs.items() %}
        // {{output_name}}
        std::shared_ptr<basis::core::transport::Publisher<{{output.cpp_message_type}}>> {{output.cpp_topic_name}}_publisher;
{%- endfor %}

        std::unique_ptr<Synchronizer> synchronizer;
    };

}